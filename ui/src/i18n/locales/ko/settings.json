{
  "title": "설정",
  "tabs": {
    "general": "일반",
    "security": "보안",
    "geoip": "GeoIP",
    "waf": "WAF",
    "system": "시스템",
    "backup": "백업",
    "logs": "로그"
  },
  "general": {
    "title": "일반 설정",
    "siteName": "사이트 이름",
    "siteNamePlaceholder": "Nginx Proxy Guard",
    "adminEmail": "관리자 이메일",
    "adminEmailPlaceholder": "admin@example.com",
    "defaultPage": "기본 페이지",
    "congratulations": "축하합니다",
    "notFound": "404 찾을 수 없음",
    "redirect": "리다이렉트",
    "custom": "사용자 정의",
    "timezone": "시간대",
    "dateFormat": "날짜 형식",
    "language": "언어"
  },
  "security": {
    "title": "보안 설정",
    "globalDdosProtection": {
      "title": "전역 DDoS 보호",
      "description": "모든 호스트에 대한 DDoS 보호를 활성화합니다",
      "enabled": "전역 DDoS 보호 활성화"
    },
    "directIpAccess": {
      "title": "직접 IP 접속",
      "description": "도메인 대신 IP로 직접 접속하는 요청을 처리합니다",
      "mode": "모드",
      "allow": "허용",
      "block": "차단",
      "redirect": "리다이렉트",
      "redirectUrl": "리다이렉트 URL",
      "redirectUrlPlaceholder": "https://example.com"
    },
    "failedLoginProtection": {
      "title": "로그인 실패 보호",
      "description": "반복적인 로그인 실패 시 IP를 차단합니다",
      "enabled": "로그인 실패 보호 활성화",
      "maxAttempts": "최대 시도 횟수",
      "lockoutDuration": "잠금 시간 (분)"
    },
    "twoFactor": {
      "title": "2단계 인증",
      "description": "추가 보안을 위한 2단계 인증",
      "enabled": "2단계 인증 활성화",
      "setup": "설정",
      "verify": "인증"
    },
    "apiTokens": {
      "title": "API 토큰",
      "description": "API 접근을 위한 토큰 관리",
      "addToken": "토큰 추가",
      "tokenName": "토큰 이름",
      "permissions": "권한",
      "expiresAt": "만료일",
      "lastUsed": "마지막 사용",
      "revoke": "취소",
      "revokeConfirm": "이 토큰을 취소하시겠습니까?"
    }
  },
  "geoip": {
    "title": "GeoIP 설정",
    "description": "IP 기반 위치 정보를 사용하여 국가별 접근 제어를 활성화합니다",
    "status": "상태",
    "active": "활성",
    "inactive": "비활성",
    "notConfigured": "설정되지 않음",
    "maxmind": {
      "title": "MaxMind GeoIP",
      "accountId": "계정 ID",
      "accountIdPlaceholder": "MaxMind 계정 ID",
      "licenseKey": "라이선스 키",
      "licenseKeyPlaceholder": "MaxMind 라이선스 키",
      "signup": "MaxMind 가입하기",
      "description": "무료 GeoLite2 데이터베이스를 사용하려면 MaxMind 계정이 필요합니다"
    },
    "database": {
      "title": "데이터베이스",
      "countryDb": "국가 데이터베이스",
      "cityDb": "도시 데이터베이스",
      "asnDb": "ASN 데이터베이스",
      "lastUpdated": "마지막 업데이트",
      "update": "업데이트",
      "download": "다운로드"
    },
    "test": {
      "title": "IP 테스트",
      "ipAddress": "IP 주소",
      "ipPlaceholder": "8.8.8.8",
      "testButton": "테스트",
      "result": "결과",
      "country": "국가",
      "city": "도시",
      "isp": "ISP"
    }
  },
  "waf": {
    "title": "WAF 설정",
    "globalSettings": {
      "title": "전역 설정",
      "enabled": "전역 WAF 활성화",
      "description": "모든 호스트에 기본 WAF 규칙을 적용합니다"
    },
    "rules": {
      "title": "규칙",
      "coreRules": "Core Rule Set",
      "customRules": "사용자 정의 규칙",
      "addRule": "규칙 추가",
      "editRule": "규칙 수정",
      "deleteRule": "규칙 삭제"
    },
    "exclusions": {
      "title": "제외",
      "description": "WAF 검사에서 제외할 경로 또는 규칙",
      "addExclusion": "제외 추가"
    },
    "logs": {
      "title": "WAF 로그",
      "viewLogs": "로그 보기",
      "clearLogs": "로그 지우기"
    }
  },
  "system": {
    "title": "시스템 설정",
    "tabs": {
      "geoip": "GeoIP",
      "acme": "SSL/ACME",
      "botfilter": "Bot Filter",
      "security": "WAF 자동 차단",
      "maintenance": "유지보수",
      "logfiles": "로그 파일",
      "systemlogs": "시스템 로그"
    },
    "systemlogs": {
      "title": "시스템 로그 수집",
      "description": "시스템 컨테이너에서 수집할 로그를 구성합니다. 로그 레벨을 낮추면 성능을 향상시킬 수 있습니다.",
      "enable": {
        "label": "시스템 로그 수집 활성화",
        "description": "Docker 컨테이너에서 로그 수집"
      },
      "levels": {
        "title": "컨테이너 로그 레벨"
      },
      "exclude": {
        "label": "제외 패턴",
        "count": "{{count}}개 패턴",
        "detailDescription": "이 패턴(정규식)과 일치하는 로그 메시지는 무시됩니다. 한 줄에 하나의 패턴을 입력하세요.",
        "placeholder": "^/health\nHEAD /"
      },
      "help": {
        "levels": "로그 레벨 설정:\n- Debug: 디버깅용 상세 로그 (가장 많음)\n- Info: 일반적인 정보성 로그 (권장)\n- Warn: 경고 메시지만 수집\n- Error: 오류 메시지만 수집 (가장 적음)\n\n레벨을 높일수록 수집되는 로그 양이 줄어듭니다.",
        "exclude": "정규표현식(Regex)을 사용하여 특정 로그 라인을 수집에서 제외합니다.\n예시:\n^/health - /health 로 시작하는 로그 제외\nHEAD / - HEAD 요청 로그 제외\n\n한 줄에 하나의 패턴을 입력하세요."
      }
    },
    "buttons": {
      "save": "변경사항 저장",
      "saving": "저장 중...",
      "updateNow": "지금 업데이트",
      "updating": "업데이트 중...",
      "view": "보기",
      "hide": "숨기기",
      "download": "다운로드",
      "delete": "삭제",
      "cancel": "취소",
      "test": {
        "label": "설정 테스트",
        "testing": "테스트 중...",
        "cancel": "취소"
      },
      "rotate": "수동 로테이션",
      "rotating": "로테이션 중..."
    },
    "geoip": {
      "saveSuccess": "GeoIP 설정이 저장되었습니다.",
      "saveFailed": "저장 실패: {{error}}",
      "updateStarted": "GeoIP 데이터베이스 업데이트가 시작되었습니다.",
      "updateFailed": "업데이트 실패: {{error}}",
      "status": {
        "title": "GeoIP 상태",
        "active": "GeoIP 데이터베이스가 활성화되어 있습니다.",
        "inactive": "GeoIP가 비활성화되어 있습니다. MaxMind 라이선스 키를 설정해주세요.",
        "error": "GeoIP 데이터베이스 오류",
        "updating": "GeoIP 데이터베이스 업데이트 중...",
        "lastUpdated": " (업데이트: {{date}})",
        "countryDb": "Country DB",
        "asnDb": "ASN DB"
      },
      "enable": {
        "label": "GeoIP 활성화",
        "description": "GeoIP를 활성화하면 국가별 접근 제어 및 로그에서 지역 정보를 확인할 수 있습니다."
      },
      "account": {
        "idLabel": "MaxMind Account ID",
        "idPlaceholder": "MaxMind Account ID 입력",
        "keyLabel": "MaxMind License Key",
        "keyPlaceholder": "MaxMind License Key 입력",
        "createAccount": "MaxMind 무료 계정 생성 →",
        "keyHelp": "라이선스 키는 MaxMind 계정 설정에서 생성할 수 있습니다."
      },
      "autoUpdate": {
        "title": "자동 업데이트 설정",
        "enableLabel": "자동 업데이트",
        "enableDescription": "GeoIP 데이터베이스를 자동으로 업데이트합니다.",
        "intervalLabel": "업데이트 주기",
        "intervals": {
          "daily": "매일",
          "weekly": "매주",
          "monthly": "매월"
        }
      },
      "history": {
        "title": "업데이트 이력",
        "date": "일시",
        "trigger": "유형",
        "status": "상태",
        "duration": "소요시간",
        "details": "세부정보",
        "auto": "자동",
        "manual": "수동",
        "success": "성공",
        "failed": "실패",
        "running": "진행 중",
        "pending": "대기 중",
        "empty": "아직 업데이트 이력이 없습니다"
      }
    },
    "acme": {
      "saveSuccess": "SSL/ACME 설정이 저장되었습니다.",
      "saveFailed": "저장 실패: {{error}}",
      "status": {
        "disabled": "ACME 비활성"
      },
      "enable": {
        "label": "ACME / Let's Encrypt 활성화",
        "description": "무료 SSL 인증서를 자동으로 발급하고 갱신합니다."
      },
      "email": {
        "label": "ACME 이메일",
        "placeholder": "admin@example.com",
        "help": "인증서 만료 알림 및 계정 복구에 사용됩니다. Let's Encrypt에서 권장합니다."
      },
      "staging": {
        "label": "스테이징 서버 사용 (테스트용)",
        "description": "테스트 시 Let's Encrypt 요청 한도를 초과하지 않도록 스테이징 서버를 사용합니다. **실제 서비스에서는 비활성화하세요.**"
      },
      "autoRenew": {
        "title": "자동 갱신 설정",
        "enableLabel": "자동 갱신",
        "enableDescription": "인증서를 만료 전에 자동으로 갱신합니다.",
        "daysBeforeLabel": "갱신 시점 (만료 며칠 전)",
        "daysBeforeHelp": "일 전",
        "help": "권장: 30일 (Let's Encrypt 인증서는 90일 유효)"
      },
      "testButton": "ACME 설정 테스트",
      "testResult": {
        "ok": "ACME 설정이 유효합니다.",
        "disabled": "ACME가 비활성화되어 있습니다.",
        "pending": "ACME 이메일이 설정되지 않았습니다. 일부 인증 기관은 이메일을 필요로 합니다."
      }
    },
    "botfilter": {
      "defaults": {
        "title": "Bot Filter 기본값 설정",
        "description": "새로 생성되는 Proxy Host에 자동으로 적용될 Bot Filter 설정의 기본값을 정의합니다. 각 Proxy Host에서 개별적으로 설정을 변경할 수 있습니다."
      },
      "enableDefault": {
        "label": "새 Proxy Host에 Bot Filter 기본 활성화",
        "description": "새로 생성되는 모든 Proxy Host에 Bot Filter가 자동으로 활성화됩니다."
      },
      "options": {
        "title": "Bot Filter 기본 옵션",
        "blockBadBots": {
          "label": "악성 봇 차단",
          "description": "스크래퍼, 스패머, 취약점 스캐너 등 알려진 악성 봇을 차단합니다."
        },
        "blockAiBots": {
          "label": "AI 크롤러 차단",
          "description": "GPTBot, ChatGPT-User, Claude-Web, Anthropic, CCBot 등 AI 학습용 크롤러를 차단합니다."
        },
        "allowSearchEngines": {
          "label": "검색 엔진 허용",
          "description": "Google, Bing, Yahoo, Baidu 등 검색 엔진 크롤러는 항상 허용합니다. SEO에 필수입니다."
        },
        "challengeSuspicious": {
          "label": "의심스러운 요청 챌린지",
          "description": "User-Agent가 없거나 의심스러운 요청에 JavaScript 챌린지를 표시합니다."
        }
      },
      "customAgents": {
        "label": "커스텀 차단 User-Agent 목록",
        "description": "추가로 차단할 User-Agent 패턴을 입력합니다. 한 줄에 하나씩 입력하세요.",
        "placeholder": "예시:\nMyCustomBot\nSomeScraperBot/*\ncurl/*"
      },
      "lists": {
        "title": "봇 리스트 관리",
        "badge": "Global",
        "description": "아래 목록은 모든 Proxy Host에서 공통으로 사용되는 봇 패턴입니다. 한 줄에 하나의 User-Agent 패턴을 입력하세요.",
        "badBots": {
          "label": "악성 봇 목록 (Bad Bots)",
          "description": "스크래퍼, 스패머, 취약점 스캐너 등 차단할 악성 봇 패턴",
          "placeholder": "AhrefsBot\nSemrushBot\nMJ12bot\n..."
        },
        "aiBots": {
          "label": "AI 크롤러 목록 (AI Bots)",
          "description": "AI 학습을 위한 크롤러 봇 패턴 (GPTBot, ClaudeBot 등)",
          "placeholder": "GPTBot\nChatGPT-User\nClaudeBot\n..."
        },
        "searchEngines": {
          "label": "검색 엔진 목록 (Search Engines)",
          "description": "SEO를 위해 항상 허용할 검색 엔진 봇 패턴",
          "placeholder": "Googlebot\nBingbot\nDuckDuckBot\n..."
        },
        "suspicious": {
          "label": "의심 클라이언트 목록 (Suspicious)",
          "description": "JS 챌린지를 적용할 의심스러운 클라이언트 패턴",
          "placeholder": "curl\nwget\npython-requests\n..."
        },
        "patternCount": "{{count}}개 패턴"
      },
      "summary": {
        "title": "현재 기본값 요약",
        "active": "활성화",
        "inactive": "비활성화",
        "blocked": "차단",
        "allowed": "허용"
      }
    },
    "waf": {
      "title": "WAF 자동 차단 설정",
      "description": "WAF 이벤트 기반 자동 IP 차단 설정을 관리합니다.",
      "status": {
        "title": "WAF 자동 차단 상태",
        "activeDescription": "WAF 이벤트 기반 자동 IP 차단이 활성화되어 있습니다.",
        "inactiveDescription": "WAF 자동 차단이 비활성화되어 있습니다.",
        "active": "Active",
        "inactive": "Inactive"
      },
      "enable": {
        "label": "WAF 자동 IP 차단",
        "description": "WAF 이벤트가 임계값을 초과하면 해당 IP를 자동으로 차단합니다."
      },
      "config": {
        "title": "자동 차단 설정",
        "threshold": {
          "label": "차단 임계값 (WAF 이벤트 수)",
          "description": "지정된 시간 내에 이 수 이상의 WAF 이벤트가 발생하면 IP를 차단합니다."
        },
        "window": {
          "label": "감지 시간 창 (초)",
          "description": "이 시간 동안의 WAF 이벤트를 집계합니다. (기본: 300초 = 5분)"
        },
        "duration": {
          "label": "차단 기간 (초)",
          "description": "IP를 차단하는 기간입니다. 0은 영구 차단입니다. (기본: 3600초 = 1시간)"
        }
      },
      "info": {
        "title": "작동 방식",
        "description": "WAF에서 차단된 요청(SQL Injection, XSS 등)이 설정한 임계값을 초과하면 해당 IP가 자동으로 차단됩니다. 차단된 IP는 WAF/Ban IP 탭에서 확인하고 관리할 수 있습니다."
      }
    },
    "maintenance": {
      "title": "Maintenance Settings",
      "description": "로그 보관 기간 및 자동 백업 설정을 관리합니다.",
      "retention": {
        "title": "로그 보관 기간 설정",
        "description": "각 로그 유형별로 보관 기간을 설정할 수 있습니다. 보관 기간이 지난 로그는 자동으로 삭제됩니다.",
        "access": "Access Logs",
        "accessDesc": "모든 HTTP 요청 (봇 필터, Exploit 차단 포함)",
        "waf": "WAF Events",
        "wafDesc": "ModSecurity 차단/탐지 이벤트",
        "error": "Error Logs",
        "errorDesc": "Nginx 오류 및 경고 로그",
        "system": "System Logs",
        "systemDesc": "시스템 및 Docker 컨테이너 로그",
        "audit": "Admin Audit",
        "auditDesc": "관리자 활동 감사 로그 (규정 준수용)",
        "days": "일",
        "years": "년",
        "months": "개월"
      },
      "presets": {
        "label": "빠른 설정:",
        "default": "기본값",
        "extended": "확장 보관",
        "minimal": "최소 보관"
      },
      "other": {
        "title": "기타 데이터 보관",
        "stats": {
          "label": "대시보드 통계 보관 기간",
          "description": "대시보드 차트 및 요약 통계 데이터"
        },
        "backup": {
          "label": "백업 파일 보관 개수",
          "description": "이 개수를 초과하면 가장 오래된 백업이 자동으로 삭제됩니다"
        },
        "count": "개",
        "backupHint": "자동 백업 설정은 Settings > Backup 탭에서 관리할 수 있습니다."
      },
      "backup": {
        "title": "자동 백업",
        "enable": {
          "label": "자동 백업 활성화",
          "description": "지정된 일정에 따라 자동으로 백업을 생성합니다."
        },
        "schedule": {
          "label": "백업 일정 (Cron 형식)",
          "help": "기본값: 0 2 * * * (매일 오전 2시). 형식: 분 시 일 월 요일"
        }
      },
      "rawlogs": {
        "title": "Raw 로그 파일 저장",
        "description": "데이터베이스 저장 외에 원본 nginx 로그 파일을 디스크에 별도로 저장합니다. 보안 감사, 규정 준수 또는 외부 로그 분석 도구 연동에 유용합니다.",
        "enable": {
          "label": "Raw 로그 파일 저장 활성화",
          "description": "활성화 시 /data/logs/ 디렉토리에 access.log, error.log 파일이 생성됩니다."
        },
        "maxSize": {
          "label": "파일당 최대 크기",
          "help": "이 크기에 도달하면 자동으로 로테이션됩니다"
        },
        "rotateCount": {
          "label": "로테이션 파일 보관 개수",
          "help": "access.log.1, access.log.2 ... 형태로 보관"
        },
        "retentionDays": {
          "label": "로테이션 파일 보관 기간",
          "help": "이 기간이 지난 로테이션 파일은 자동 삭제"
        },
        "compress": {
          "label": "로테이션 파일 압축",
          "help": "로테이션된 파일을 gzip으로 압축하여 디스크 공간을 절약합니다"
        },
        "estimate": {
          "title": "예상 최대 디스크 사용량",
          "description": "Access + Error 로그 파일 기준 약 {{size}} MB",
          "compressed": " (압축 시)"
        }
      }
    },
    "logfiles": {
      "status": {
        "title": "Raw 로그 파일 상태",
        "active": "Raw 로그 저장이 활성화되어 있습니다. 총 {{count}}개 파일, {{size}}",
        "inactive": "Raw 로그 저장이 비활성화되어 있습니다. Maintenance 탭에서 활성화할 수 있습니다."
      },
      "list": {
        "title": "로그 파일 목록",
        "compressed": "압축됨",
        "empty": "로그 파일이 없습니다",
        "emptyHelp": "Raw 로그 저장을 활성화하면 여기에 파일이 표시됩니다"
      },
      "modal": {
        "empty": "(빈 파일)",
        "delete": {
          "title": "파일 삭제",
          "confirm": "{{filename}} 파일을 삭제하시겠습니까?"
        }
      }
    },
    "nginx": {
      "title": "Nginx",
      "reload": "Nginx 재시작",
      "testConfig": "설정 테스트",
      "viewConfig": "설정 보기",
      "status": "상태"
    },
    "update": {
      "title": "업데이트",
      "currentVersion": "현재 버전",
      "latestVersion": "최신 버전",
      "checkUpdate": "업데이트 확인",
      "updateAvailable": "업데이트 가능",
      "upToDate": "최신 버전입니다"
    }
  },
  "backup": {
    "title": "백업 및 복원",
    "create": {
      "title": "백업 생성",
      "description": "현재 설정을 백업 파일로 저장합니다",
      "button": "백업 생성",
      "includeData": "데이터 포함",
      "includeLogs": "로그 포함",
      "includeConfig": "설정 포함"
    },
    "restore": {
      "title": "복원",
      "description": "백업 파일에서 설정을 복원합니다",
      "button": "복원",
      "selectFile": "파일 선택",
      "warning": "현재 설정이 덮어쓰여집니다"
    },
    "history": {
      "title": "백업 기록",
      "date": "날짜",
      "size": "크기",
      "download": "다운로드",
      "restore": "복원",
      "delete": "삭제"
    },
    "schedule": {
      "title": "자동 백업",
      "enabled": "자동 백업 활성화",
      "frequency": "빈도",
      "daily": "매일",
      "weekly": "매주",
      "monthly": "매월",
      "retention": "보관 기간"
    }
  },
  "captcha": {
    "title": "CAPTCHA 챌린지 설정",
    "description": "GeoIP 제한에서 Challenge Mode를 사용할 때 보여줄 CAPTCHA 설정입니다",
    "enable": {
      "label": "CAPTCHA Challenge 활성화",
      "description": "활성화하면 GeoIP Challenge Mode가 설정된 프록시 호스트에서 차단 대신 CAPTCHA 페이지를 표시합니다."
    },
    "stats": {
      "title": "챌린지 통계 (24시간)",
      "total": "총 챌린지",
      "passed": "통과",
      "failed": "실패",
      "activeTokens": "활성 토큰"
    },
    "provider": {
      "title": "CAPTCHA 제공자",
      "subTitle": "CAPTCHA Provider",
      "recaptcha_v2": "Google reCAPTCHA v2 (체크박스)",
      "recaptcha_v3": "Google reCAPTCHA v3 (점수 기반)",
      "turnstile": "Cloudflare Turnstile",
      "help": {
        "recaptcha_v3": "reCAPTCHA v3는 사용자 상호작용 없이 점수 기반으로 봇을 감지합니다.",
        "turnstile": "Cloudflare Turnstile은 무료이며 개인정보 친화적인 CAPTCHA입니다.",
        "recaptcha_v2": "reCAPTCHA v2는 \"I am not a robot\" 체크박스를 표시합니다."
      },
      "links": "CAPTCHA 키 발급:"
    },
    "keys": {
      "siteKey": "사이트 키",
      "siteKeyDesc": "CAPTCHA provider에서 발급받은 Site Key입니다.",
      "secretKey": "비밀 키",
      "secretKeyDesc": "CAPTCHA provider에서 발급받은 Secret Key입니다.",
      "secretKeySet": "Secret Key가 이미 설정되어 있습니다. 변경하려면 새 값을 입력하세요."
    },
    "recaptcha": {
      "score": "최소 점수 (0.0 - 1.0)",
      "scoreDesc": "이 점수 미만의 요청은 봇으로 간주됩니다. 0.5가 일반적인 권장값입니다."
    },
    "tokenValidity": {
      "label": "토큰 유효 기간 (초)",
      "desc": "CAPTCHA를 통과한 후 접속이 허용되는 시간입니다. (기본: 86400초 = 24시간)"
    },
    "appearance": {
      "title": "Challenge Page 외관",
      "pageTitle": "페이지 제목",
      "theme": "테마",
      "message": "페이지 메시지",
      "messageDesc": "CAPTCHA 위에 표시될 메시지입니다."
    },
    "messages": {
      "saveSuccess": "CAPTCHA 설정이 저장되었습니다."
    }
  },
  "messages": {
    "saveSuccess": "설정이 저장되었습니다",
    "saveFailed": "설정 저장에 실패했습니다",
    "testSuccess": "테스트가 성공했습니다",
    "testFailed": "테스트가 실패했습니다",
    "backupSuccess": "백업이 생성되었습니다",
    "backupFailed": "백업 생성에 실패했습니다",
    "restoreSuccess": "복원이 완료되었습니다",
    "restoreFailed": "복원에 실패했습니다"
  },
  "global": {
    "title": "Global Settings",
    "description": "Nginx 전역 설정을 관리합니다. 변경 후 저장하면 Nginx가 자동으로 재로드됩니다.",
    "buttons": {
      "reset": "기본값으로 초기화",
      "save": "변경사항 저장",
      "saving": "저장 중..."
    },
    "presets": {
      "title": "Quick Presets",
      "current": "현재:",
      "custom": "Custom",
      "modified": "(수정됨)",
      "descriptions": {
        "balanced": {
          "label": "Balanced",
          "description": "기본 균형 잡힌 설정. 대부분의 경우에 적합합니다."
        },
        "performance": {
          "label": "Performance",
          "description": "고성능 설정. 높은 트래픽과 빠른 응답을 위해 최적화되었습니다."
        },
        "security": {
          "label": "Security",
          "description": "보안 강화 설정. 최신 TLS만 사용하고 보안 헤더가 추가됩니다."
        }
      }
    },
    "tabs": {
      "worker": "Worker",
      "http": "HTTP",
      "performance": "Performance",
      "compression": "Compression",
      "ssl": "SSL/TLS",
      "timeout": "Timeouts",
      "advanced": "Advanced"
    },
    "performance": {
      "buffer": {
        "title": "프록시 버퍼 설정",
        "description": "업스트림 서버로부터의 응답을 버퍼링하는 방식을 설정합니다. 적절한 버퍼 크기는 메모리 사용량과 성능 사이의 균형을 맞춥니다."
      },
      "openFileCache": {
        "title": "Open File Cache"
      },
      "tips": "Tip: 프록시 버퍼 크기가 너무 작으면 응답이 임시 파일에 기록되어 디스크 I/O가 발생합니다. 대용량 응답이 많은 경우 버퍼 크기를 늘리면 성능이 향상됩니다. Open File Cache는 정적 파일이 많은 경우 파일 디스크립터를 캐시하여 성능을 향상시킵니다."
    },
    "fields": {
      "worker_processes": {
        "label": "워커 프로세스 수",
        "description": "요청을 처리하는 워커 프로세스 수입니다. 0 = CPU 코어 수에 따라 자동 감지. 값이 높을수록 동시 처리 능력이 향상됩니다.",
        "placeholder": "0 = 자동"
      },
      "worker_connections": {
        "label": "Worker 연결 수",
        "description": "각 워커 프로세스가 동시에 처리할 수 있는 최대 연결 수입니다. 높을수록 더 많은 동시 접속을 처리할 수 있습니다."
      },
      "multi_accept": {
        "label": "Multi Accept",
        "description": "활성화하면 워커가 새 연결을 하나씩이 아닌 모두 한 번에 수락합니다. 높은 트래픽에서 성능이 향상됩니다."
      },
      "use_epoll": {
        "label": "Epoll 사용",
        "description": "Linux에서 효율적인 이벤트 처리 방식인 epoll을 사용합니다. 많은 동시 연결 처리 시 성능이 향상됩니다."
      },
      "keepalive_timeout": {
        "label": "Keepalive 타임아웃 (초)",
        "description": "연결을 유지하는 시간입니다. 클라이언트가 추가 요청을 보낼 수 있도록 연결을 열어둡니다. 너무 높으면 리소스 낭비, 너무 낮으면 새 연결 오버헤드가 증가합니다."
      },
      "keepalive_requests": {
        "label": "Keepalive 요청 수",
        "description": "하나의 keepalive 연결에서 처리할 수 있는 최대 요청 수입니다. 높을수록 연결 재사용이 증가하여 성능이 향상됩니다."
      },
      "client_max_body_size": {
        "label": "최대 요청 크기",
        "description": "클라이언트가 업로드할 수 있는 최대 본문 크기입니다 (예: 100m, 1g). 파일 업로드 제한에 영향을 줍니다."
      },
      "types_hash_max_size": {
        "label": "Types Hash 크기",
        "description": "MIME 타입 해시 테이블의 최대 크기입니다. 일반적으로 기본값이면 충분합니다."
      },
      "sendfile": {
        "label": "Sendfile",
        "description": "커널에서 파일을 직접 전송하는 sendfile() 시스템 콜을 사용합니다. 정적 파일 전송 속도가 향상됩니다."
      },
      "tcp_nopush": {
        "label": "TCP Nopush",
        "description": "sendfile 사용 시 응답 헤더와 파일 내용을 하나의 패킷으로 전송합니다. 네트워크 효율성이 향상됩니다."
      },
      "tcp_nodelay": {
        "label": "TCP Nodelay",
        "description": "Nagle 알고리즘을 비활성화하여 작은 패킷도 즉시 전송합니다. 실시간 응답이 필요한 경우 유용합니다."
      },
      "server_tokens": {
        "label": "Server Tokens",
        "description": "활성화하면 응답 헤더에 Nginx 버전이 표시됩니다. 보안을 위해 비활성화를 권장합니다."
      },
      "gzip_enabled": {
        "label": "Gzip 압축",
        "description": "응답을 gzip으로 압축합니다. 대역폭을 절약하고 페이지 로드 속도를 향상시킵니다."
      },
      "gzip_comp_level": {
        "label": "압축 레벨 (1-9)",
        "description": "압축 강도입니다. 높을수록 압축률이 좋지만 CPU 사용량이 증가합니다. 권장값: 5-6"
      },
      "gzip_min_length": {
        "label": "최소 압축 크기 (bytes)",
        "description": "이 크기 미만의 응답은 압축하지 않습니다. 작은 파일 압축은 오버헤드가 더 클 수 있습니다."
      },
      "gzip_types": {
        "label": "압축 MIME 타입",
        "description": "압축할 콘텐츠 타입 목록입니다. 텍스트 기반 콘텐츠(HTML, CSS, JS, JSON 등)에 효과적입니다."
      },
      "gzip_vary": {
        "label": "Vary 헤더 추가",
        "description": "Vary: Accept-Encoding 헤더를 추가합니다. CDN이나 프록시 캐시에서 올바른 버전을 제공하도록 합니다."
      },
      "brotli_enabled": {
        "label": "Brotli 압축",
        "description": "Brotli 압축을 활성화합니다. Gzip보다 더 높은 압축률을 제공하며, 대부분의 최신 브라우저에서 지원됩니다."
      },
      "brotli_static": {
        "label": "Brotli 정적 파일",
        "description": "미리 압축된 .br 파일이 있으면 해당 파일을 제공합니다. 정적 자산의 CPU 부하를 줄입니다."
      },
      "brotli_comp_level": {
        "label": "Brotli 압축 레벨 (1-11)",
        "description": "Brotli 압축 강도입니다. 1-4: 빠른 압축, 5-9: 균형, 10-11: 최대 압축 (CPU 부하 높음). 권장값: 4-6"
      },
      "brotli_min_length": {
        "label": "Brotli 최소 크기",
        "description": "Brotli 압축을 적용할 최소 응답 크기(바이트)입니다. 작은 파일은 압축 효과가 없습니다."
      },
      "brotli_types": {
        "label": "Brotli 압축 MIME 타입",
        "description": "Brotli로 압축할 콘텐츠 타입 목록입니다. 텍스트 기반 콘텐츠에 가장 효과적입니다."
      },
      "ssl_protocols": {
        "label": "SSL 프로토콜",
        "description": "허용할 TLS 프로토콜 버전입니다. TLSv1.2와 TLSv1.3만 사용하는 것이 안전합니다."
      },
      "ssl_ciphers": {
        "label": "SSL 암호화 스위트",
        "description": "사용할 암호화 알고리즘 목록입니다. 보안과 호환성의 균형을 맞춰야 합니다."
      },
      "ssl_session_cache": {
        "label": "SSL 세션 캐시",
        "description": "SSL 세션을 캐시하여 재연결 시 핸드셰이크를 건너뜁니다. 성능이 향상됩니다."
      },
      "ssl_session_timeout": {
        "label": "SSL 세션 타임아웃",
        "description": "SSL 세션 캐시의 유효 시간입니다. 예: 1d (1일), 1h (1시간)"
      },
      "ssl_prefer_server_ciphers": {
        "label": "서버 암호 우선",
        "description": "서버가 선호하는 암호화 스위트를 사용합니다. 보안 강화를 위해 권장됩니다."
      },
      "ssl_stapling": {
        "label": "OCSP Stapling",
        "description": "인증서 상태를 서버에서 캐시하여 클라이언트가 별도로 확인하지 않아도 됩니다. 연결 속도가 향상됩니다."
      },
      "ssl_stapling_verify": {
        "label": "Stapling 검증",
        "description": "OCSP 응답을 검증합니다. ssl_stapling과 함께 사용됩니다."
      },
      "ssl_session_tickets": {
        "label": "Session Tickets",
        "description": "TLS 세션 티켓을 사용하여 세션을 재개합니다. 서버 부하가 감소합니다."
      },
      "client_body_timeout": {
        "label": "클라이언트 본문 타임아웃 (초)",
        "description": "클라이언트 요청 본문을 읽는 타임아웃입니다. 느린 업로드에 대비해 적절히 설정하세요."
      },
      "client_header_timeout": {
        "label": "클라이언트 헤더 타임아웃 (초)",
        "description": "클라이언트 요청 헤더를 읽는 타임아웃입니다. 느린 클라이언트로부터 보호합니다."
      },
      "send_timeout": {
        "label": "응답 전송 타임아웃 (초)",
        "description": "클라이언트에 응답을 전송하는 타임아웃입니다."
      },
      "proxy_connect_timeout": {
        "label": "프록시 연결 타임아웃 (초)",
        "description": "업스트림 서버에 연결하는 타임아웃입니다. 업스트림이 응답하지 않을 때 대기 시간입니다."
      },
      "proxy_send_timeout": {
        "label": "프록시 전송 타임아웃 (초)",
        "description": "업스트림 서버에 요청을 전송하는 타임아웃입니다."
      },
      "proxy_read_timeout": {
        "label": "프록시 읽기 타임아웃 (초)",
        "description": "업스트림 서버로부터 응답을 읽는 타임아웃입니다. 느린 API 응답에 대비해 설정하세요."
      },
      "resolver": {
        "label": "DNS 리졸버",
        "description": "도메인 이름을 해석할 DNS 서버입니다. 예: 8.8.8.8 8.8.4.4 valid=300s"
      },
      "error_log_level": {
        "label": "에러 로그 레벨",
        "description": "로깅 상세도입니다. debug가 가장 상세하고, crit가 가장 간결합니다."
      },
      "access_log_enabled": {
        "label": "접속 로그 활성화",
        "description": "모든 요청을 로그에 기록합니다. 트래픽이 많으면 디스크 사용량이 증가할 수 있습니다."
      },
      "custom_http_config": {
        "label": "커스텀 HTTP 설정",
        "description": "추가 nginx 설정을 직접 입력할 수 있습니다. 고급 사용자용입니다."
      },
      "proxy_buffer_size": {
        "label": "프록시 버퍼 크기",
        "description": "업스트림 서버 응답의 첫 부분(헤더)을 읽는 버퍼 크기입니다. 기본값: 8k"
      },
      "proxy_buffers": {
        "label": "프록시 버퍼 수와 크기",
        "description": "응답 버퍼의 개수와 크기입니다. 형식: '개수 크기' (예: 8 32k)"
      },
      "proxy_busy_buffers_size": {
        "label": "Busy 버퍼 크기",
        "description": "응답이 완전히 읽히지 않은 상태에서 클라이언트로 전송할 수 있는 버퍼 크기입니다."
      },
      "proxy_max_temp_file_size": {
        "label": "최대 임시 파일 크기",
        "description": "버퍼가 가득 찬 경우 응답을 저장할 임시 파일의 최대 크기입니다. 0으로 설정하면 임시 파일 사용을 비활성화합니다."
      },
      "proxy_temp_file_write_size": {
        "label": "임시 파일 쓰기 크기",
        "description": "임시 파일에 한 번에 쓸 수 있는 데이터 크기입니다."
      },
      "open_file_cache_enabled": {
        "label": "Open File Cache 활성화",
        "description": "열린 파일 디스크립터와 디렉토리 조회 결과를 캐시합니다. 정적 파일이 많은 경우 성능이 향상됩니다."
      },
      "open_file_cache_max": {
        "label": "최대 캐시 항목 수",
        "description": "캐시에 보관할 최대 항목 수입니다."
      },
      "open_file_cache_inactive": {
        "label": "비활성 시간",
        "description": "이 시간 동안 접근하지 않은 항목은 캐시에서 제거됩니다. (예: 20s, 60s)"
      },
      "open_file_cache_valid": {
        "label": "유효성 검사 주기",
        "description": "캐시된 항목의 유효성을 확인하는 주기입니다. (예: 30s, 60s)"
      },
      "open_file_cache_min_uses": {
        "label": "최소 사용 횟수",
        "description": "이 횟수만큼 접근된 파일만 캐시에 유지됩니다."
      },
      "open_file_cache_errors": {
        "label": "오류 캐시",
        "description": "파일을 찾을 수 없음 등의 오류도 캐시합니다. 존재하지 않는 파일에 대한 반복 요청 시 성능이 향상됩니다."
      },
      "reset_timedout_connection": {
        "label": "타임아웃 연결 리셋",
        "description": "타임아웃된 연결을 FIN 대신 RST로 종료하여 즉시 소켓을 해제합니다. 서버 리소스 절약에 도움됩니다."
      },
      "resolver_timeout": {
        "label": "DNS 리졸버 타임아웃",
        "description": "DNS 조회 시 응답을 기다리는 최대 시간입니다. (예: 30s)"
      },
      "custom_stream_config": {
        "label": "커스텀 Stream 설정",
        "description": "TCP/UDP 프록시를 위한 nginx stream 블록 설정입니다. 고급 사용자용입니다."
      }
    },
    "tips": {
      "compression": "Tip: Gzip과 Brotli를 동시에 활성화하면 브라우저가 지원하는 최적의 압축 방식이 자동으로 선택됩니다. Brotli는 Gzip보다 20-30% 더 높은 압축률을 제공하지만, 구형 브라우저는 Gzip만 지원합니다."
    },
    "advanced": {
      "directIpAccess": {
        "title": "IP 직접 접속 처리",
        "description": "도메인 없이 서버 IP로 직접 접속하는 요청을 어떻게 처리할지 설정합니다. IP 직접 접속은 대부분 봇이나 스캐너에 의한 것입니다.",
        "options": {
          "allow": {
            "label": "Nginx Proxy Guard 웰컴 페이지 표시",
            "description": "서버 IP로 접속하면 Nginx Proxy Guard 웰컴 페이지를 표시합니다. 서버가 정상 작동 중인지 확인할 수 있습니다."
          },
          "block403": {
            "label": "403 Forbidden 반환",
            "description": "403 Forbidden 응답을 반환합니다. JSON 형태로 접근 거부 메시지를 표시합니다."
          },
          "block444": {
            "label": "연결 종료 (444)",
            "description": "응답 없이 연결을 즉시 종료합니다. 스캐너에게 가장 효과적입니다."
          }
        },
        "note": {
          "title": "참고",
          "description": "Health check (/health)와 ACME 챌린지 (/.well-known/acme-challenge/)는 이 설정과 관계없이 항상 허용됩니다."
        }
      },
      "ddos": {
        "title": "DDoS 보호 (전역 설정)",
        "description": "모든 호스트에 적용되는 전역 DDoS 보호 설정입니다. Proxy Host별 Rate Limit은 이 설정에 추가로 적용됩니다.",
        "connectionLimit": {
          "title": "연결 수 제한",
          "description": "IP당 최대 동시 연결 수를 제한합니다.",
          "perIp": "IP당 최대 연결 수",
          "zoneSize": "Zone 크기"
        },
        "requestLimit": {
          "title": "요청 속도 제한",
          "description": "IP당 초당 요청 수를 제한합니다.",
          "rate": "초당 요청 수 (r/s)",
          "burst": "Burst (초과 허용)",
          "zoneSize": "Zone 크기"
        },
        "responseLimit": {
          "title": "응답 속도 제한 (대역폭)",
          "description": "클라이언트에게 전송하는 응답 속도를 제한합니다. 0 = 무제한",
          "rate": "속도 제한 (bytes/s, 0=무제한)",
          "ratePlaceholder": "예: 102400 (100KB/s)",
          "after": "적용 시작 크기",
          "afterPlaceholder": "예: 500k, 1m"
        },
        "bandwidthLimit": {
          "title": "대역폭 제한",
          "description": "클라이언트 다운로드 속도를 제한합니다. 0 = 무제한",
          "rate": "속도 제한 (bytes/s)",
          "after": "적용 시작 크기"
        },
        "connectionReset": {
          "title": "타임아웃 연결 리셋",
          "description": "타임아웃된 연결을 즉시 리셋하여 리소스를 해제합니다."
        },
        "info": {
          "title": "Proxy Host별 Rate Limit과의 차이점",
          "description": "이 설정은 **모든 호스트에 기본 적용**됩니다. Proxy Host에서 설정하는 Rate Limit은 해당 호스트에만 **추가로 적용**되는 더 세밀한 제어입니다."
        }
      },
      "nginxConfNote": {
        "title": "참고: nginx.conf 수준 설정",
        "description": "아래 설정들(Reset Timedout Connection, Resolver Timeout, Custom Stream Config)은 nginx.conf의 http/stream 블록에 적용되는 설정입니다. 변경 사항을 적용하려면 nginx를 재시작해야 합니다."
      },
      "errorLogLevels": {
        "debug": "debug - 모든 정보 (개발용)",
        "info": "info - 일반 정보",
        "notice": "notice - 주의할 사항",
        "warn": "warn - 경고 (권장)",
        "error": "error - 오류만",
        "crit": "crit - 심각한 오류만"
      },
      "customConfigPlaceholder": "# 추가 nginx http 설정을 여기에 입력하세요",
      "customStreamConfigPlaceholder": "# 추가 nginx stream 설정을 여기에 입력하세요"
    }
  },
  "apiTokens": {
    "title": "API Tokens",
    "subtitle": "프로그래밍 방식으로 API에 접근하기 위한 토큰을 관리합니다.",
    "apiDocs": "API Documentation",
    "createToken": "토큰 생성",
    "createNew": "새 토큰 생성",
    "form": {
      "tokenName": "토큰 이름",
      "tokenNamePlaceholder": "My API Token",
      "permissionGroups": "권한 그룹",
      "individualPermissions": "개별 권한",
      "allowedIps": "허용 IP (선택사항)",
      "allowedIpsPlaceholder": "192.168.1.1, 10.0.0.0/8",
      "allowedIpsHelp": "쉼표로 구분",
      "allowedIpsEmptyHelp": "쉼표로 구분, 비워두면 모든 IP에서 접근 가능",
      "rateLimit": "Rate Limit (req/hour)",
      "expiresIn": "만료 기간"
    },
    "expires": {
      "7d": "7일",
      "30d": "30일",
      "90d": "90일",
      "1y": "1년",
      "never": "만료 없음"
    },
    "table": {
      "name": "이름",
      "token": "토큰",
      "permissions": "권한",
      "lastUsed": "마지막 사용",
      "status": "상태",
      "actions": "작업"
    },
    "status": {
      "active": "활성",
      "revoked": "취소됨",
      "expired": "만료됨"
    },
    "actions": {
      "edit": "수정",
      "revoke": "비활성화",
      "delete": "삭제",
      "save": "저장",
      "cancel": "취소",
      "copy": "복사",
      "close": "닫기"
    },
    "modal": {
      "created": "API Token 생성됨",
      "createdWarning": "이 토큰은 다시 표시되지 않습니다. 안전한 곳에 복사해두세요."
    },
    "confirm": {
      "revoke": "이 토큰을 비활성화하시겠습니까?",
      "delete": "이 토큰을 영구적으로 삭제하시겠습니까?"
    },
    "empty": "아직 생성된 API 토큰이 없습니다.",
    "usage": {
      "title": "API 사용 방법",
      "description": "API 요청 시 Authorization 헤더에 토큰을 포함하세요:",
      "example": "Authorization: Bearer ng_your_token_here"
    },
    "more": "+{{count}}개 더"
  },
  "backupManager": {
    "title": "백업 및 복원",
    "uploadRestore": "업로드 및 복원",
    "createBackup": "백업 생성",
    "stats": {
      "totalBackups": "총 백업",
      "totalSize": "총 크기",
      "lastBackup": "마지막 백업",
      "retention": "보관 기간",
      "never": "없음",
      "days": "일"
    },
    "autoBackup": {
      "title": "자동 백업 설정",
      "enable": "자동 백업 활성화",
      "enableDescription": "지정된 일정에 따라 자동으로 백업을 생성합니다",
      "schedule": "백업 일정 (Cron 형식)",
      "scheduleHelp": "기본값: {{default}} (매일 오전 2시). 형식: 분 시 일 월 요일",
      "retentionCount": "백업 보관 개수",
      "retentionHelp": "이 개수를 초과하면 가장 오래된 백업이 자동으로 삭제됩니다",
      "count": "개"
    },
    "history": {
      "title": "백업 기록",
      "empty": "백업이 없습니다. 첫 백업을 생성하세요."
    },
    "status": {
      "completed": "완료",
      "inProgress": "진행 중",
      "failed": "실패"
    },
    "labels": {
      "config": "설정",
      "certs": "인증서",
      "database": "데이터베이스"
    },
    "buttons": {
      "download": "다운로드",
      "restore": "복원",
      "delete": "삭제",
      "saveChanges": "변경사항 저장",
      "saving": "저장 중...",
      "cancel": "취소",
      "creating": "생성 중...",
      "restoring": "복원 중...",
      "close": "닫기"
    },
    "createModal": {
      "title": "백업 생성",
      "includeConfig": "설정 파일 포함",
      "includeCerts": "SSL 인증서 포함",
      "includeDatabase": "데이터베이스 포함",
      "description": "설명 (선택사항)",
      "descriptionPlaceholder": "백업 설명..."
    },
    "uploadModal": {
      "title": "백업 업로드 및 복원",
      "warning": "경고: 업로드된 백업 파일에서 모든 설정을 복원합니다. 현재 설정이 덮어쓰여집니다.",
      "selectFile": "백업 파일 (.tar.gz)",
      "clickToSelect": "클릭하여 백업 파일 선택",
      "dragAndDrop": "또는 여기로 드래그 앤 드롭",
      "restoreInfo": "복원되는 항목:",
      "items": {
        "proxyHosts": "Proxy Hosts 및 보안 설정",
        "redirectHosts": "Redirect Hosts",
        "accessLists": "Access Control Lists",
        "certificates": "SSL 인증서",
        "wafConfig": "WAF 설정",
        "globalSettings": "전역 설정"
      }
    },
    "confirm": {
      "delete": "이 백업을 삭제하시겠습니까?",
      "restore": "\"{{filename}}\"에서 복원하시겠습니까? 현재 설정이 덮어쓰여집니다.",
      "uploadRestore": "이 백업을 업로드하고 복원하시겠습니까? 현재 설정이 덮어쓰여집니다."
    },
    "messages": {
      "saveSuccess": "자동 백업 설정이 저장되었습니다.",
      "saveFailed": "저장 실패: {{error}}",
      "restoreSuccess": "복원이 완료되었습니다! 페이지를 새로고침하여 업데이트된 설정을 확인하세요.",
      "restoreFailed": "복원 실패: {{error}}",
      "uploadSuccess": "백업이 업로드되고 복원되었습니다! 페이지를 새로고침하여 업데이트된 설정을 확인하세요.",
      "uploadFailed": "업로드 및 복원 실패: {{error}}",
      "invalidFormat": "잘못된 파일 형식입니다. .tar.gz 백업 파일을 선택하세요."
    },
    "progress": {
      "title": "백업 생성 중",
      "titleComplete": "백업 완료",
      "titleFailed": "백업 실패",
      "initializing": "백업 초기화 중...",
      "exportingDatabase": "데이터베이스 내보내기 중...",
      "exportingConfig": "설정 파일 내보내기 중...",
      "exportingCerts": "SSL 인증서 내보내기 중...",
      "creatingArchive": "압축 파일 생성 중...",
      "complete": "완료!",
      "completedAt": "완료 시각",
      "pleaseWait": "잠시만 기다려주세요..."
    }
  },
  "help": {
    "global": {
      "worker_processes": "Nginx 워커 프로세스 수입니다. 'auto'로 설정하면 CPU 코어 수에 맞춰집니다. 트래픽이 많으면 코어 수만큼 설정하는 것이 좋습니다.",
      "worker_connections": "각 워커가 동시에 처리할 수 있는 최대 연결 수입니다. 너무 낮으면 접속 오류가 발생할 수 있습니다. (기본값: 1024)",
      "multi_accept": "활성화하면 워커가 여러 연결을 한 번에 수락합니다. 트래픽이 매우 많을 때 성능이 향상될 수 있습니다.",
      "use_epoll": "Linux 환경에서 고성능 이벤트 처리 방식인 epoll을 사용합니다. 대규모 동시 접속 처리에 필수적입니다.",
      "keepalive_timeout": "클라이언트와의 연결을 유지하는 시간입니다. 너무 길면 메모리를 낭비하고, 너무 짧으면 재연결 오버헤드가 발생합니다.",
      "keepalive_requests": "하나의 Keepalive 연결에서 처리할 최대 요청 수입니다. 이 값을 넘으면 연결을 닫습니다.",
      "client_max_body_size": "업로드 가능한 최대 파일 크기를 제한합니다. 대용량 파일 업로드가 필요하면 늘리세요.",
      "types_hash_max_size": "MIME 타입을 저장하는 해시 테이블 크기입니다. 기본값이면 충분합니다.",
      "sendfile": "커널 레벨에서 파일을 전송하여 성능을 극대화합니다. 정적 콘텐츠 제공 시 필수 옵션입니다.",
      "tcp_nopush": "sendfile과 함께 사용되며, 패킷 수를 줄여 네트워크 효율을 높입니다.",
      "tcp_nodelay": "작은 데이터 패킷도 즉시 전송하여 반응 속도를 높입니다. 실시간 애플리케이션에 유리합니다.",
      "server_tokens": "보안을 위해 Nginx 버전 정보 노출을 숨기는 것이 좋습니다.",
      "gzip_enabled": "텍스트 데이터(HTML, CSS, JS)를 압축하여 전송량을 줄입니다. 속도 향상에 큰 도움이 됩니다.",
      "gzip_comp_level": "압축률을 설정합니다. 5~6 정도가 CPU 사용량 대비 효율이 가장 좋습니다.",
      "gzip_min_length": "너무 작은 파일은 압축해도 효과가 없으므로 압축하지 않습니다.",
      "gzip_types": "압축할 파일 형식을 지정합니다. 이미지나 비디오는 이미 압축되어 있어 제외하는 것이 좋습니다.",
      "gzip_vary": "캐시 서버가 압축된 버전과 안 된 버전을 구분할 수 있도록 Vary 헤더를 추가합니다.",
      "brotli_enabled": "Google이 개발한 Brotli 압축을 사용합니다. Gzip보다 압축률이 더 높습니다.",
      "brotli_comp_level": "Brotli 압축 강도입니다. 4~6 정도를 권장합니다.",
      "brotli_types": "Brotli로 압축할 콘텐츠 타입을 지정합니다.",
      "ssl_protocols": "보안 취약점이 있는 구버전 프로토콜(SSLv3, TLSv1.0, TLSv1.1)은 사용하지 않는 것이 안전합니다.",
      "ssl_ciphers": "사용할 암호화 알고리즘 목록입니다. 강력한 보안을 위해 최신 설정을 유지하세요.",
      "ssl_session_cache": "SSL 핸드셰이크 정보를 캐시하여 재접속 속도를 높입니다.",
      "ssl_session_timeout": "SSL 세션 캐시 유지 시간입니다.",
      "ssl_prefer_server_ciphers": "클라이언트가 아닌 서버가 지정한 암호화 알고리즘을 우선 사용합니다.",
      "ssl_stapling": "인증서 유효성 확인 속도를 높여 접속 지연을 줄입니다.",
      "ssl_stapling_verify": "OCSP 응답의 유효성을 서버가 직접 검증합니다.",
      "ssl_session_tickets": "세션 티켓을 사용하여 SSL 연결을 빠르게 재개합니다.",
      "client_body_timeout": "클라이언트가 데이터를 너무 늦게 보내면 연결을 끊습니다.",
      "client_header_timeout": "클라이언트가 헤더를 너무 늦게 보내면 연결을 끊습니다.",
      "send_timeout": "클라이언트로 데이터를 보낼 때 타임아웃을 설정합니다.",
      "proxy_connect_timeout": "백엔드 서버로 연결을 시도할 때의 타임아웃입니다.",
      "proxy_send_timeout": "백엔드 서버로 데이터를 보낼 때의 타임아웃입니다.",
      "proxy_read_timeout": "백엔드 서버로부터 응답을 기다리는 시간입니다. 처리 시간이 긴 API가 있다면 늘리세요.",
      "resolver": "도메인 이름을 IP로 변환할 때 사용할 DNS 서버입니다.",
      "error_log_level": "로그에 기록할 에러의 상세 수준입니다. 디버깅 목적이 아니면 'warn'이나 'error'를 권장합니다.",
      "access_log_enabled": "모든 접속 기록을 남깁니다. 디스크 공간 관리가 필요할 수 있습니다.",
      "custom_http_config": "Nginx http 블록에 추가할 사용자 정의 설정을 입력합니다.",
      "proxy_buffer_size": "업스트림 서버에서 응답의 첫 부분(헤더)을 읽을 때 사용하는 버퍼 크기입니다.",
      "proxy_buffers": "응답을 버퍼링하는 데 사용할 버퍼의 수와 크기입니다. 형식: '개수 크기'",
      "proxy_busy_buffers_size": "아직 완전히 읽지 않은 응답을 클라이언트에 전송할 때 사용할 수 있는 버퍼 크기입니다.",
      "proxy_max_temp_file_size": "버퍼가 가득 찬 경우 응답을 저장할 임시 파일의 최대 크기입니다. 0으로 설정하면 임시 파일을 사용하지 않습니다.",
      "proxy_temp_file_write_size": "임시 파일에 한 번에 쓸 수 있는 데이터 크기입니다.",
      "open_file_cache_enabled": "정적 파일에 대한 파일 디스크립터와 메타데이터를 캐시합니다. 정적 콘텐츠가 많은 사이트에서 성능이 향상됩니다.",
      "open_file_cache_max": "캐시에 저장할 최대 항목 수입니다.",
      "open_file_cache_inactive": "이 시간 동안 접근하지 않은 캐시 항목은 제거됩니다.",
      "open_file_cache_valid": "캐시된 항목의 유효성을 다시 확인하는 주기입니다.",
      "open_file_cache_min_uses": "비활성 시간 내에 이 횟수 이상 접근된 파일만 캐시에 유지됩니다.",
      "open_file_cache_errors": "파일을 찾을 수 없음과 같은 오류도 캐시합니다.",
      "reset_timedout_connection": "타임아웃된 연결을 RST 패킷으로 즉시 종료합니다. 소켓 리소스를 빠르게 해제하여 서버 성능이 향상됩니다.",
      "resolver_timeout": "DNS 조회 시 응답을 기다리는 최대 시간입니다.",
      "custom_stream_config": "TCP/UDP 로드 밸런싱을 위한 nginx stream 블록 설정입니다.",
      "ddos": {
        "connectionLimit": "동일 IP에서의 동시 연결 수를 제한하여 서버 자원을 보호합니다.",
        "requestLimit": "동일 IP에서의 초당 요청 수를 제한하여 과도한 요청을 차단합니다.",
        "responseLimit": "클라이언트 다운로드 속도를 제한하여 대역폭 독점을 방지합니다.",
        "connectionReset": "타임아웃 발생 시 연결을 즉시 강제 종료합니다.",
        "bandwidthLimit": "클라이언트 다운로드 속도를 제한하여 대역폭을 공정하게 분배합니다."
      }
    },
    "geoip": {
      "enable": "GeoIP를 활성화하면 국가별로 접속을 차단하거나 허용할 수 있습니다. MaxMind 무료 계정이 필요합니다.",
      "account": "GeoLite2 데이터베이스를 다운로드하려면 MaxMind Account ID와 License Key가 필요합니다.",
      "accountId": "MaxMind 계정 설정에서 발급받은 6자리 숫자 ID입니다.",
      "licenseKey": "MaxMind 계정에서 생성한 라이선스 키입니다.",
      "updateInterval": "GeoIP 데이터베이스 자동 업데이트 주기를 설정합니다."
    },
    "acme": {
      "enable": "Let's Encrypt에서 무료 SSL 인증서를 자동으로 발급하고 갱신합니다.",
      "email": "인증서 만료 알림 및 계정 복구에 사용됩니다. 실제 사용하는 이메일을 입력하세요.",
      "staging": "테스트 시에는 Staging 서버를 사용하여 발급 제한(Rate Limit)을 피하세요. 프로덕션 환경에서는 반드시 비활성화해야 합니다.",
      "renewBefore": "인증서 만료 며칠 전에 갱신할지 설정합니다. 기본값(30일)을 권장합니다."
    },
    "botFilter": {
      "defaults": "여기서 설정한 값은 '새로 생성되는' 프록시 호스트의 기본값이 됩니다. 기존 호스트에는 영향을 주지 않습니다.",
      "lists": "모든 프록시 호스트에서 공통으로 사용할 User-Agent 차단/허용 목록을 관리합니다.",
      "badBots": "스팸, 크롤러 등 악성 봇의 접근을 차단합니다.",
      "aiBots": "GPT, Claude 등 AI 데이터 수집 봇을 차단합니다.",
      "searchEngines": "Google, Bing 등 검색 엔진의 접근은 항상 허용하여 SEO에 불이익이 없도록 합니다.",
      "suspicious": "의심스러운 클라이언트(curl, python-requests 등)에 대해 JS 챌린지를 수행합니다."
    },
    "botfilter": {
      "defaults": "여기서 설정한 값은 '새로 생성되는' 프록시 호스트의 기본값이 됩니다. 기존 호스트에는 영향을 주지 않습니다.",
      "lists": "모든 프록시 호스트에서 공통으로 사용할 User-Agent 차단/허용 목록을 관리합니다.",
      "badBots": "스팸, 크롤러 등 악성 봇의 접근을 차단합니다.",
      "aiBots": "GPT, Claude 등 AI 데이터 수집 봇을 차단합니다.",
      "searchEngines": "Google, Bing 등 검색 엔진의 접근은 항상 허용하여 SEO에 불이익이 없도록 합니다.",
      "suspicious": "의심스러운 클라이언트(curl, python-requests 등)에 대해 JS 챌린지를 수행합니다."
    },
    "waf": {
      "autoBan": "단시간 내에 과도한 WAF 경고(SQL 인젝션 시도 등)를 유발하는 IP를 자동으로 차단합니다.",
      "threshold": "설정된 시간(감지 기간) 동안 이 횟수만큼 감지되면 차단합니다.",
      "window": "이 시간 동안 발생한 이벤트를 카운트합니다.",
      "duration": "차단된 IP가 해제될 때까지의 시간입니다. 0으로 설정하면 영구 차단됩니다."
    },
    "maintenance": {
      "logRetention": "오래된 로그를 자동으로 삭제하여 디스크 공간을 확보합니다. (매일 자정 또는 서비스 재시작 시 실행)",
      "rawLogs": "Nginx 원본 로그(access.log, error.log)를 파일로 저장합니다. 보안 감사나 외부 분석 도구 사용 시 유용합니다.",
      "access": "모든 HTTP 요청 기록입니다 (봇 필터 및 Exploit 차단 로그 포함). 트래픽 분석에 사용됩니다.",
      "waf": "ModSecurity 차단/탐지 이벤트 로그입니다.",
      "error": "Nginx 에러 및 경고 로그입니다.",
      "system": "시스템 및 Docker 컨테이너 로그입니다.",
      "audit": "관리자 활동 감사 로그입니다.",
      "stats": "대시보드 차트 및 통계 데이터 보관 기간입니다."
    },
    "backup": {
      "enable": "정해진 일정에 따라 전체 설정을 자동으로 백업합니다.",
      "schedule": "Cron 형식으로 백업 주기를 설정합니다. (예: 0 2 * * * = 매일 새벽 2시)",
      "retention": "보관할 백업 파일의 최대 개수입니다. 이 개수를 초과하면 오래된 백업부터 삭제됩니다."
    }
  }
}