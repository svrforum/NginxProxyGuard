import { test, expect } from '@playwright/test';
import { WAFPage } from '../../pages';
import { TestDataFactory } from '../../utils/test-data-factory';
import { APIHelper } from '../../utils/api-helper';
import { TIMEOUTS } from '../../fixtures/test-data';

test.describe('WAF Exploit Rules', () => {
  let wafPage: WAFPage;
  let apiHelper: APIHelper;

  test.beforeEach(async ({ page, request }) => {
    wafPage = new WAFPage(page);
    apiHelper = new APIHelper(request);
    await apiHelper.login();
  });

  test.describe('Exploit Rules Page', () => {
    test('should display exploit rules page', async () => {
      await wafPage.gotoExploitRules();
      await wafPage.expectWAFPage();
      await expect(wafPage.page).toHaveURL(/\/waf\/exploit-rules/);
    });

    test('should display exploit rules list', async () => {
      await wafPage.gotoExploitRules();

      const rulesVisible = await wafPage.exploitRulesList.isVisible();
      expect(rulesVisible).toBeTruthy();
    });

    test('should show rule toggle switches', async () => {
      await wafPage.gotoExploitRules();

      const toggleCount = await wafPage.ruleToggle.count();
      expect(toggleCount).toBeGreaterThanOrEqual(0);
    });
  });

  test.describe('Rule Categories', () => {
    test('should fetch exploit rules via API', async () => {
      const rules = await apiHelper.getWafExploitRules();
      expect(Array.isArray(rules)).toBeTruthy();
    });

    test('should have categorized rules', async () => {
      const rules = await apiHelper.getWafExploitRules();

      if (rules.length > 0) {
        // Each rule should have a category
        const hasCategories = rules.every(rule => rule.category !== undefined);
        expect(hasCategories).toBeTruthy();
      }
    });

    test('should have rule descriptions', async () => {
      const rules = await apiHelper.getWafExploitRules();

      if (rules.length > 0) {
        // Each rule should have a name
        const hasNames = rules.every(rule => rule.name !== undefined);
        expect(hasNames).toBeTruthy();
      }
    });
  });

  test.describe('Enable/Disable Rules', () => {
    test('should toggle rule enabled state', async ({ page }) => {
      await wafPage.gotoExploitRules();

      const firstToggle = wafPage.ruleToggle.first();
      if (await firstToggle.isVisible()) {
        await firstToggle.click();
        await page.waitForTimeout(500);

        // Should not error
        const isVisible = await firstToggle.isVisible();
        expect(isVisible).toBeTruthy();
      }
    });

    test('should save rule state changes', async ({ page }) => {
      await wafPage.gotoExploitRules();

      // Toggle a rule
      const firstToggle = wafPage.ruleToggle.first();
      if (await firstToggle.isVisible()) {
        await firstToggle.click();

        // Save if there's a save button
        if (await wafPage.saveButton.isVisible()) {
          await wafPage.saveButton.click();
          await page.waitForTimeout(500);
        }
      }
    });
  });

  test.describe('Rule Pattern Testing', () => {
    test('should detect SQL injection patterns', async () => {
      const sqlPayloads = TestDataFactory.getSqlInjectionPayloads();

      for (const payload of sqlPayloads.slice(0, 2)) { // Test first 2
        const result = await apiHelper.testWafPayload(payload);
        // SQL injection should be blocked
        expect(result.blocked).toBeTruthy();
      }
    });

    test('should detect XSS patterns', async () => {
      const xssPayloads = TestDataFactory.getXssPayloads();

      for (const payload of xssPayloads.slice(0, 2)) { // Test first 2
        const result = await apiHelper.testWafPayload(payload);
        // XSS should be blocked
        expect(result.blocked).toBeTruthy();
      }
    });

    test('should detect path traversal patterns', async () => {
      const pathPayloads = TestDataFactory.getPathTraversalPayloads();

      for (const payload of pathPayloads.slice(0, 2)) { // Test first 2
        const result = await apiHelper.testWafPayload(payload);
        // Path traversal should be blocked
        expect(result.blocked).toBeTruthy();
      }
    });

    test('should allow safe payloads', async () => {
      const safePayloads = TestDataFactory.getSafePayloads();

      for (const payload of safePayloads) {
        const result = await apiHelper.testWafPayload(payload);
        // Safe payloads should not be blocked
        expect(result.blocked).toBeFalsy();
      }
    });
  });

  test.describe('Rule Matching', () => {
    test('should return matched rules for blocked requests', async () => {
      const payload = "' OR '1'='1"; // Classic SQL injection

      const result = await apiHelper.testWafPayload(payload);

      if (result.blocked) {
        expect(result.matched_rules).toBeDefined();
        expect(Array.isArray(result.matched_rules)).toBeTruthy();
      }
    });

    test('should return empty matched rules for allowed requests', async () => {
      const payload = 'Hello World'; // Safe payload

      const result = await apiHelper.testWafPayload(payload);

      expect(result.blocked).toBeFalsy();
      expect(result.matched_rules?.length || 0).toBe(0);
    });
  });
});

test.describe('Exploit Rule Filters', () => {
  let wafPage: WAFPage;
  let apiHelper: APIHelper;

  test.beforeEach(async ({ page, request }) => {
    wafPage = new WAFPage(page);
    apiHelper = new APIHelper(request);
    await apiHelper.login();
  });

  test('should filter rules by category', async ({ page }) => {
    await wafPage.gotoExploitRules();

    // Look for category filter
    const categoryFilter = page.locator('select, [role="combobox"]').filter({
      has: page.locator('option:has-text("SQL"), option:has-text("XSS")'),
    }).first();

    if (await categoryFilter.isVisible()) {
      await categoryFilter.selectOption({ index: 1 });
      await page.waitForTimeout(500);

      // Rules should be filtered
      const ruleCount = await wafPage.ruleToggle.count();
      expect(ruleCount).toBeGreaterThanOrEqual(0);
    }
  });

  test('should search rules by name', async ({ page }) => {
    await wafPage.gotoExploitRules();

    const searchInput = page.locator('input[type="search"], input[placeholder*="search"]').first();

    if (await searchInput.isVisible()) {
      await searchInput.fill('SQL');
      await page.waitForTimeout(500);

      // Should filter to SQL-related rules
    }
  });
});
