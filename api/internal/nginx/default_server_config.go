package nginx

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"
	"text/template"
)

// Default server config template
const defaultServerTemplate = `# Default server - catch-all for unmatched requests
# Direct IP Access Action: {{.Action}}
# Generated by Nginx Proxy Guard

# HTTP default server
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;

    # Health check endpoint (always allowed)
    location /health {
        access_log off;
        return 200 'OK';
        add_header Content-Type text/plain;
    }

    # ACME HTTP-01 Challenge support (for Let's Encrypt)
    location /.well-known/acme-challenge/ {
        root /etc/nginx/acme-challenge;
        try_files $uri =404;
    }

    # Custom error pages
    error_page 403 /403.html;
    error_page 502 /502.html;
    error_page 503 /503.html;
    error_page 504 /504.html;

    location = /403.html {
        root /etc/nginx/html;
        internal;
    }
    location = /502.html {
        root /etc/nginx/html;
        internal;
    }
    location = /503.html {
        root /etc/nginx/html;
        internal;
    }
    location = /504.html {
        root /etc/nginx/html;
        internal;
    }

    # Public API proxy (for font settings, etc.) - always available
    location /api/v1/public/ {
        proxy_pass http://api:8080/api/v1/public/;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

{{if eq .Action "block_444"}}
    # Block direct IP access - close connection without response
    location / {
        return 444;
    }
{{else if eq .Action "block_403"}}
    # Block direct IP access - return 403 Forbidden with custom page
    location / {
        return 403;
    }
{{else}}
    # Allow direct IP access - show Nginx Proxy Guard welcome page
    root /usr/share/nginx/html;
    index index.html;

    location / {
        try_files $uri $uri/ =404;
    }
{{end}}
}

# HTTPS default server - reject SSL handshake for unknown/disabled hosts
server {
    listen 443 ssl default_server;
    listen [::]:443 ssl default_server;
    server_name _;

    # Reject SSL handshake immediately - no certificate warning, just connection reset
    ssl_reject_handshake on;
}
`

// DefaultServerConfigData holds data for default server config generation
type DefaultServerConfigData struct {
	Action string // allow, block_403, block_444
}

// GenerateDefaultServerConfig generates the default server config based on settings
func (m *Manager) GenerateDefaultServerConfig(ctx context.Context, action string) error {
	// Validate action
	if action != "allow" && action != "block_403" && action != "block_444" {
		action = "allow" // Default to allow if invalid
	}

	funcMap := GetSimpleTemplateFuncMap()

	tmpl, err := template.New("default_server").Funcs(funcMap).Parse(defaultServerTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse default server template: %w", err)
	}

	data := DefaultServerConfigData{Action: action}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute default server template: %w", err)
	}

	// Use zzz_ prefix to ensure this loads last (after proxy host configs)
	configFile := filepath.Join(m.configPath, "zzz_default.conf")
	if err := os.WriteFile(configFile, buf.Bytes(), 0644); err != nil {
		return fmt.Errorf("failed to write default server config file: %w", err)
	}

	// Remove old default.conf if it exists (migration from old naming)
	oldConfigFile := filepath.Join(m.configPath, "default.conf")
	os.Remove(oldConfigFile) // Ignore error if doesn't exist

	return nil
}
