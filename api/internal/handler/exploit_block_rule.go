package handler

import (
	"context"
	"encoding/json"
	"log"
	"net/http"
	"strings"

	"nginx-proxy-guard/internal/model"
	"nginx-proxy-guard/internal/repository"
)

// ExploitRuleConfigRegenerator interface for regenerating nginx configs
type ExploitRuleConfigRegenerator interface {
	RegenerateConfigsForExploitRules(ctx context.Context) error
	RegenerateConfigForHost(ctx context.Context, hostID string) error
}

// parseExploitRulePath parses path params from URL path
// Handles patterns like /api/v1/exploit-rules/{id}
func parseExploitRulePath(path string) string {
	path = strings.TrimPrefix(path, "/api/v1/exploit-rules/")
	path = strings.TrimPrefix(path, "/api/exploit-rules/")
	parts := strings.Split(path, "/")
	if len(parts) > 0 {
		return parts[0]
	}
	return ""
}

// parseExploitRuleHostPath parses host and rule IDs from URL path
// Handles patterns like /api/v1/exploit-rules/hosts/{hostId}/rules/{ruleId}/exclude
func parseExploitRuleHostPath(path string) (hostID, ruleID string) {
	path = strings.TrimPrefix(path, "/api/v1/exploit-rules/hosts/")
	path = strings.TrimPrefix(path, "/api/exploit-rules/hosts/")
	parts := strings.Split(path, "/")
	if len(parts) >= 1 {
		hostID = parts[0]
	}
	// Look for rules/{ruleId} pattern
	for i, part := range parts {
		if part == "rules" && i+1 < len(parts) {
			ruleID = parts[i+1]
			break
		}
	}
	return hostID, ruleID
}

// ExploitBlockRuleHandler handles exploit blocking rule requests
type ExploitBlockRuleHandler struct {
	repo        *repository.ExploitBlockRuleRepository
	proxyRepo   *repository.ProxyHostRepository
	configRegen ExploitRuleConfigRegenerator
}

// NewExploitBlockRuleHandler creates a new exploit block rule handler
func NewExploitBlockRuleHandler(
	repo *repository.ExploitBlockRuleRepository,
	proxyRepo *repository.ProxyHostRepository,
	configRegen ExploitRuleConfigRegenerator,
) *ExploitBlockRuleHandler {
	return &ExploitBlockRuleHandler{
		repo:        repo,
		proxyRepo:   proxyRepo,
		configRegen: configRegen,
	}
}

// regenerateAllExploitConfigs regenerates nginx configs for all hosts with block_exploits enabled
func (h *ExploitBlockRuleHandler) regenerateAllExploitConfigs(ctx context.Context) {
	if h.configRegen == nil {
		return
	}
	go func() {
		if err := h.configRegen.RegenerateConfigsForExploitRules(context.Background()); err != nil {
			log.Printf("[ExploitRules] Failed to regenerate configs: %v", err)
		}
	}()
}

// regenerateHostConfig regenerates nginx config for a specific host
func (h *ExploitBlockRuleHandler) regenerateHostConfig(ctx context.Context, hostID string) {
	if h.configRegen == nil {
		return
	}
	go func() {
		if err := h.configRegen.RegenerateConfigForHost(context.Background(), hostID); err != nil {
			log.Printf("[ExploitRules] Failed to regenerate config for host %s: %v", hostID, err)
		}
	}()
}

// ListRules returns all exploit block rules grouped by category
func (h *ExploitBlockRuleHandler) ListRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	rules, err := h.repo.GetAll(ctx)
	if err != nil {
		log.Printf("Failed to list exploit rules: %v", err)
		http.Error(w, "Failed to list rules", http.StatusInternalServerError)
		return
	}

	globalExclusions, err := h.repo.GetGlobalExclusions(ctx)
	if err != nil {
		log.Printf("Failed to get global exclusions: %v", err)
		globalExclusions = []model.GlobalExploitRuleExclusion{}
	}

	// Build exclusion map for quick lookup
	exclusionMap := make(map[string]bool)
	for _, e := range globalExclusions {
		exclusionMap[e.RuleID] = true
	}

	// Group rules by category
	categoryMap := make(map[string][]model.ExploitBlockRuleWithStatus)
	for _, rule := range rules {
		ruleWithStatus := model.ExploitBlockRuleWithStatus{
			ExploitBlockRule: rule,
			GloballyDisabled: exclusionMap[rule.ID],
		}
		categoryMap[rule.Category] = append(categoryMap[rule.Category], ruleWithStatus)
	}

	// Build category list
	categoryOrder := []string{"sql_injection", "xss", "rfi", "path_traversal", "scanner", "http_method", "custom"}
	var categories []model.ExploitBlockRuleCategory

	for _, cat := range categoryOrder {
		if rules, ok := categoryMap[cat]; ok {
			categories = append(categories, model.ExploitBlockRuleCategory{
				ID:          cat,
				Name:        model.ExploitRuleCategoryNames[cat],
				Description: model.ExploitRuleCategoryDescriptions[cat],
				RuleCount:   len(rules),
				Rules:       rules,
			})
		}
	}

	response := model.ExploitRulesResponse{
		Categories:       categories,
		TotalRules:       len(rules),
		GlobalExclusions: globalExclusions,
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetRule returns a single rule by ID
func (h *ExploitBlockRuleHandler) GetRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	ruleID := parseExploitRulePath(r.URL.Path)
	if ruleID == "" {
		http.Error(w, "Rule ID required", http.StatusBadRequest)
		return
	}

	rule, err := h.repo.GetByID(ctx, ruleID)
	if err != nil {
		log.Printf("Failed to get rule: %v", err)
		http.Error(w, "Failed to get rule", http.StatusInternalServerError)
		return
	}
	if rule == nil {
		http.Error(w, "Rule not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(rule)
}

// CreateRule creates a new custom exploit rule
func (h *ExploitBlockRuleHandler) CreateRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var req model.CreateExploitRuleRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	// Validate required fields
	if req.Category == "" || req.Name == "" || req.Pattern == "" || req.PatternType == "" {
		http.Error(w, "Category, name, pattern, and pattern_type are required", http.StatusBadRequest)
		return
	}

	rule, err := h.repo.Create(ctx, &req)
	if err != nil {
		log.Printf("Failed to create exploit rule: %v", err)
		http.Error(w, "Failed to create rule", http.StatusInternalServerError)
		return
	}

	// Regenerate nginx configs for all hosts with block_exploits enabled
	h.regenerateAllExploitConfigs(ctx)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(rule)
}

// UpdateRule updates an exploit rule
func (h *ExploitBlockRuleHandler) UpdateRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	ruleID := parseExploitRulePath(r.URL.Path)
	if ruleID == "" {
		http.Error(w, "Rule ID required", http.StatusBadRequest)
		return
	}

	var req model.UpdateExploitRuleRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		http.Error(w, "Invalid request body", http.StatusBadRequest)
		return
	}

	rule, err := h.repo.Update(ctx, ruleID, &req)
	if err != nil {
		log.Printf("Failed to update exploit rule: %v", err)
		http.Error(w, "Failed to update rule", http.StatusInternalServerError)
		return
	}

	// Regenerate nginx configs for all hosts with block_exploits enabled
	h.regenerateAllExploitConfigs(ctx)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(rule)
}

// DeleteRule deletes a custom exploit rule
func (h *ExploitBlockRuleHandler) DeleteRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	ruleID := parseExploitRulePath(r.URL.Path)
	if ruleID == "" {
		http.Error(w, "Rule ID required", http.StatusBadRequest)
		return
	}

	if err := h.repo.Delete(ctx, ruleID); err != nil {
		log.Printf("Failed to delete exploit rule: %v", err)
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// Regenerate nginx configs for all hosts with block_exploits enabled
	h.regenerateAllExploitConfigs(ctx)

	w.WriteHeader(http.StatusNoContent)
}

// ToggleRule toggles a rule's enabled status
func (h *ExploitBlockRuleHandler) ToggleRule(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	ruleID := parseExploitRulePath(r.URL.Path)
	if ruleID == "" {
		http.Error(w, "Rule ID required", http.StatusBadRequest)
		return
	}

	rule, err := h.repo.ToggleEnabled(ctx, ruleID)
	if err != nil {
		log.Printf("Failed to toggle exploit rule: %v", err)
		http.Error(w, "Failed to toggle rule", http.StatusInternalServerError)
		return
	}

	// Regenerate nginx configs for all hosts with block_exploits enabled
	h.regenerateAllExploitConfigs(ctx)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(rule)
}

// AddGlobalExclusion adds a global rule exclusion
func (h *ExploitBlockRuleHandler) AddGlobalExclusion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	ruleID := parseExploitRulePath(r.URL.Path)
	if ruleID == "" {
		http.Error(w, "Rule ID required", http.StatusBadRequest)
		return
	}

	var req struct {
		Reason string `json:"reason"`
	}
	json.NewDecoder(r.Body).Decode(&req)

	// Get username from context
	username := ""
	if user := ctx.Value("user"); user != nil {
		if u, ok := user.(*model.User); ok {
			username = u.Username
		}
	}

	exclusion, err := h.repo.AddGlobalExclusion(ctx, ruleID, req.Reason, username)
	if err != nil {
		log.Printf("Failed to add global exclusion: %v", err)
		http.Error(w, "Failed to add exclusion", http.StatusInternalServerError)
		return
	}

	// Regenerate nginx configs for all hosts with block_exploits enabled
	h.regenerateAllExploitConfigs(ctx)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(exclusion)
}

// RemoveGlobalExclusion removes a global rule exclusion
func (h *ExploitBlockRuleHandler) RemoveGlobalExclusion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	ruleID := parseExploitRulePath(r.URL.Path)
	if ruleID == "" {
		http.Error(w, "Rule ID required", http.StatusBadRequest)
		return
	}

	if err := h.repo.RemoveGlobalExclusion(ctx, ruleID); err != nil {
		log.Printf("Failed to remove global exclusion: %v", err)
		http.Error(w, "Failed to remove exclusion", http.StatusInternalServerError)
		return
	}

	// Regenerate nginx configs for all hosts with block_exploits enabled
	h.regenerateAllExploitConfigs(ctx)

	w.WriteHeader(http.StatusNoContent)
}

// ListHostsWithExploitBlocking returns hosts with exploit blocking info
func (h *ExploitBlockRuleHandler) ListHostsWithExploitBlocking(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	hosts, _, err := h.proxyRepo.List(ctx, 1, 1000, "", "", "")
	if err != nil {
		log.Printf("Failed to list hosts: %v", err)
		http.Error(w, "Failed to list hosts", http.StatusInternalServerError)
		return
	}

	exclusionCounts, err := h.repo.GetHostExclusionCounts(ctx)
	if err != nil {
		log.Printf("Failed to get exclusion counts: %v", err)
		exclusionCounts = make(map[string]int)
	}

	var result []model.ExploitRuleHostConfig
	for _, host := range hosts {
		if host.BlockExploits {
			name := "Unnamed Host"
			if len(host.DomainNames) > 0 {
				name = host.DomainNames[0]
			}
			result = append(result, model.ExploitRuleHostConfig{
				ProxyHostID:    host.ID,
				ProxyHostName:  name,
				BlockExploits:  host.BlockExploits,
				ExclusionCount: exclusionCounts[host.ID],
			})
		}
	}

	response := model.ExploitRuleHostsResponse{
		Hosts: result,
		Total: len(result),
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

// GetHostRules returns rules with exclusion status for a specific host
func (h *ExploitBlockRuleHandler) GetHostRules(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	hostID, _ := parseExploitRuleHostPath(r.URL.Path)
	if hostID == "" {
		http.Error(w, "Host ID required", http.StatusBadRequest)
		return
	}

	rules, err := h.repo.GetRulesWithExclusionStatus(ctx, hostID)
	if err != nil {
		log.Printf("Failed to get host rules: %v", err)
		http.Error(w, "Failed to get rules", http.StatusInternalServerError)
		return
	}

	// Group by category
	categoryMap := make(map[string][]model.ExploitBlockRuleWithStatus)
	for _, rule := range rules {
		categoryMap[rule.Category] = append(categoryMap[rule.Category], rule)
	}

	categoryOrder := []string{"sql_injection", "xss", "rfi", "path_traversal", "scanner", "http_method", "custom"}
	var categories []model.ExploitBlockRuleCategory

	for _, cat := range categoryOrder {
		if catRules, ok := categoryMap[cat]; ok {
			categories = append(categories, model.ExploitBlockRuleCategory{
				ID:          cat,
				Name:        model.ExploitRuleCategoryNames[cat],
				Description: model.ExploitRuleCategoryDescriptions[cat],
				RuleCount:   len(catRules),
				Rules:       catRules,
			})
		}
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"categories":   categories,
		"total_rules":  len(rules),
	})
}

// AddHostExclusion adds a host-specific rule exclusion
func (h *ExploitBlockRuleHandler) AddHostExclusion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	hostID, ruleID := parseExploitRuleHostPath(r.URL.Path)
	if hostID == "" || ruleID == "" {
		http.Error(w, "Host ID and Rule ID required", http.StatusBadRequest)
		return
	}

	var req struct {
		Reason string `json:"reason"`
	}
	json.NewDecoder(r.Body).Decode(&req)

	username := ""
	if user := ctx.Value("user"); user != nil {
		if u, ok := user.(*model.User); ok {
			username = u.Username
		}
	}

	exclusion, err := h.repo.AddHostExclusion(ctx, hostID, ruleID, req.Reason, username)
	if err != nil {
		log.Printf("Failed to add host exclusion: %v", err)
		http.Error(w, "Failed to add exclusion", http.StatusInternalServerError)
		return
	}

	// Regenerate nginx config for this specific host only
	h.regenerateHostConfig(ctx, hostID)

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusCreated)
	json.NewEncoder(w).Encode(exclusion)
}

// RemoveHostExclusion removes a host-specific rule exclusion
func (h *ExploitBlockRuleHandler) RemoveHostExclusion(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	hostID, ruleID := parseExploitRuleHostPath(r.URL.Path)
	if hostID == "" || ruleID == "" {
		http.Error(w, "Host ID and Rule ID required", http.StatusBadRequest)
		return
	}

	if err := h.repo.RemoveHostExclusion(ctx, hostID, ruleID); err != nil {
		log.Printf("Failed to remove host exclusion: %v", err)
		http.Error(w, "Failed to remove exclusion", http.StatusInternalServerError)
		return
	}

	// Regenerate nginx config for this specific host only
	h.regenerateHostConfig(ctx, hostID)

	w.WriteHeader(http.StatusNoContent)
}
